# Data-Structure
记录考研数据结构的代码

## Chapter 2 Link List

***

1. 在循环双链表中，头结点的prior也要指向尾结点，尾结点的next要指向头结点
2. 静态链表要求预先分配一大片连续的内存空间，指针指的是数组中的相对位置
3. 头指针或尾指针是用来指明链表中的第一个结点或最后一个结点，如果只有尾指针是无法访问到单链表的头结点的！！！（不是都是从头开始要看指针）
4. 头结点是在第一个结点前的一个结点，但无论有没有头结点都有头指针都指向第一个结点

## Chapter 3 Stack and Queue

***

1. 注意栈顶指针是指向第一个元素还是第一个元素前面一个元素

2. n个元素进栈，出栈元素不同排列的个数为
   $$
   C_{2n}^n * \frac{1}{n+1}
   $$
   卡特兰数

3. 采用共享栈节省存储空间，降低发生下溢的可能

4. 栈用于递归、迷宫求解、括号匹配、深度优先、进制转换

5. 队列用于缓冲区、CPU竞争资源（页面替换算法）

6. 对于同一个问题的递归问题求解和非递归问题求解，非递归算法的效率通常高一些，递归求解效率低，但代码量少

7. 在计算输入输出受限的双端队列时，先划出一个道路然后右边可以进可以出，只在左边进行受限的限制

8. 十字链表和三元组表适合稀疏矩阵

9. 在计算矩阵元素在数组中下标时一定要注意数组是否从0开始！！！，如果说存入C语言的数组就默认从0开始！！，还要注意是行优先还是列优先！！！



## Chapter 4 String

***

1. ```c++
   * 朴素模式匹配算法 模式串（可能存在的子串）
   * 若模式串长度为m，主串长度为n，则
   * 匹配成功的最好时间复杂度为:O(m)
   * 匹配失败的最好时间复杂度为:O(n-m+1)=O(n-m)~O(n)
   * 最坏时间复杂度：最多需要（n-m+1）*m O(nm)
   ```

2. ```c++
   
    * 获得next数组
    * 串的前缀：包含第一个字符，且不包括最后一个字符的子串
    * 串的后缀：包含最后一个字符，且不包含第一个字符的子串
    * 当第j个字符匹配失败，由前1~j-1个字符组成的串记为S，则：next[j]=S的最长相等前缀后缀长度+1
    * 特别地next数组放弃了第一个next[0]
    * next[1]=0,next[2]=1
    * next[1]=0的原因是表示模式串应该右移一位，主串当前指针后移一位再和模式串的第一个字符进行比较
    * 获得nextval数组
    * 提出的nextval数组的目的在于如果返回的j值所对应的字母与之前的字母相同就不应该多跳转一回，应当直接赋给之前的字母所对应的next值
    * 用nextval数组可以优化KMP算法
    * 注意位序是从0开始还是从1开始，如果从0开始就全部减一
   *KMP算法平均时间复杂度为O（n+m）
   
   ```
