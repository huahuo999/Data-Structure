# Data-Structure
记录考研数据结构的代码

## Chapter 2 Link List

***

1. 在循环双链表中，头结点的prior也要指向尾结点，尾结点的next要指向头结点
2. 静态链表要求预先分配一大片连续的内存空间，指针指的是数组中的相对位置
3. 头指针或尾指针是用来指明链表中的第一个结点或最后一个结点，如果只有尾指针是无法访问到单链表的头结点的！！！（不是都是从头开始要看指针）
4. 头结点是在第一个结点前的一个结点，但无论有没有头结点都有头指针都指向第一个结点

## Chapter 3 Stack and Queue

***

1. 注意栈顶指针是指向第一个元素还是第一个元素前面一个元素

2. n个元素进栈，出栈元素不同排列的个数为
   $$
   C_{2n}^n * \frac{1}{n+1}
   $$
   卡特兰数

3. 采用共享栈节省存储空间，降低发生下溢的可能

4. 栈用于递归、迷宫求解、括号匹配、深度优先、进制转换

5. 队列用于缓冲区、CPU竞争资源（页面替换算法）

6. 对于同一个问题的递归问题求解和非递归问题求解，非递归算法的效率通常高一些，递归求解效率低，但代码量少

7. 在计算输入输出受限的双端队列时，先划出一个道路然后右边可以进可以出，只在左边进行受限的限制

8. 十字链表和三元组表适合稀疏矩阵

9. 在计算矩阵元素在数组中下标时一定要注意数组是否从0开始！！！，如果说存入C语言的数组就默认从0开始！！，还要注意是行优先还是列优先！！！

***



## Chapter 4 String

***

1. ```c++
   * 朴素模式匹配算法 模式串（可能存在的子串）
   * 若模式串长度为m，主串长度为n，则
   * 匹配成功的最好时间复杂度为:O(m)
   * 匹配失败的最好时间复杂度为:O(n-m+1)=O(n-m)~O(n)
   * 最坏时间复杂度：最多需要（n-m+1）*m O(nm)
   ```

2. ```c++
   
    * 获得next数组
    * 串的前缀：包含第一个字符，且不包括最后一个字符的子串
    * 串的后缀：包含最后一个字符，且不包含第一个字符的子串
    * 当第j个字符匹配失败，由前1~j-1个字符组成的串记为S，则：next[j]=S的最长相等前缀后缀长度+1
    * 特别地next数组放弃了第一个next[0]
    * next[1]=0,next[2]=1
    * next[1]=0的原因是表示模式串应该右移一位，主串当前指针后移一位再和模式串的第一个字符进行比较
    * 获得nextval数组
    * 提出的nextval数组的目的在于如果返回的j值所对应的字母与之前的字母相同就不应该多跳转一回，应当直接赋给之前的字母所对应的next值
    * 用nextval数组可以优化KMP算法
    * 注意位序是从0开始还是从1开始，如果从0开始就全部减一
   *KMP算法平均时间复杂度为O（n+m）
   
   ```

****

## Chapter 5 Tree and Binary Tree

***



1. 树的性质：

   * 结点数 = 总度数 + 1（根节点）

   * 度为m的树和m叉树的区别是

     前者: （先有结点再定义）

     1. 任意结点的度<=m，

     2. 至少有一个结点度数=m

     3. 一定是非空树，至少有m+1个结点

     后者：（先定义后有结点）

     1. 任意结点度数<=m

     2. 允许所有结点的度都<m

     3. 可以是空树

   * 度为m的树第i层至多有m^(i-1)个结点

   * m叉树第i层至多有m^(i-1)个结点

   * 高度为h的m叉树至多有(m^h-1)/(m-1)个结点

   * 高度为h的m叉树至少有h个结点

   * 高度为h，度为m的树至少有h+m-1个结点

   * 有n个结点的m叉树的最小高度为[logm(n*(m-1)) + 1]向上取整（只有小数就加一）

2. 几种二叉树：

   * 满二叉树：一颗高度为h，且含有2^(h-1)个结点的树
     1. 只有最后一层有叶子结点
     2. 不存在度为1的结点
     3. 按层序1开始编号，结点i的左孩子为2*i，右孩子为2*i+1;结点i的父节点为[i/2] （向下取整）
   * 完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树
     1. 只有最后两层可能有叶子结点
     2. 最多只有一个度为1的结点
     3. 按层序1开始编号，结点i的左孩子为2*i，右孩子为2*i+1;结点i的父节点为[i/2] （向下取整）
     4. 当i<=[n/2] （向下取整）为分支节点，i>[n/2]为叶子结点
   * 二叉排序树：一颗二叉树或空二叉树
     1. 左子树上所有结点的关键字均小于根节点的关键字
     2. 右子树上所有结点的关键字均大于根节点的关键字
     3. 左子树和右子树又各是一颗排序二叉树
   * 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1

3. 二叉树常考性质：

   * 设非空二叉树中度为0、1和2的结点个数分别为n0、n1、n2则n0 = n2+1
   * 二叉树的第i层最多有2^(i-1)个结点

4. 完全二叉树常考性质

   * 具有n个结点的完全二叉树的高度h为log2(n+1)向上取整， log2（n）+1向下取整

5. 叶子结点也可以是根节点

6. 当tag为0时，先序线索二叉树找不到先序前驱

7. 当tag为0时，后序线索二叉树找不到后序后继

8. 双亲表示法和孩子表示法：顺序存储结点数据，前者保存父节点在数组中的下标，后者保存孩子链表头指针，前者找父节点方便找孩子不方便，后者找孩子方便，找父节点不方便

9. 孩子兄弟表示法：用二叉链表存储树——左孩子右兄弟 常用于树与二叉树的相互转换

10. 森林与二叉树的转化：森林中各个树的根节点之间视为兄弟关系，用二叉链表存储森林-左孩子右兄弟

11. 二叉排序树（BST） 平衡二叉树（AVL） 查找长度（ASL）

12. 二叉排序树的查找效率主要取决于树的高度，平衡二叉树的平均查找长度ASL为O（log2n）,当只有一个右子树时，平均查找长度为O（n）

13. | 树       | 森林     | 二叉树   |
    | -------- | -------- | -------- |
    | 先根遍历 | 先序遍历 | 先序遍历 |
    | 后根遍历 | 中序遍历 | 中序遍历 |







***

## Chapter 6  Graph

1. ```
   /*邻接矩阵法
    * 空间复杂度O(|V|^2)只和顶点数有关与实际边数无关
    * 适合用于存储稠密图，不适于稀疏图
    * 可以用压缩矩阵
    * 表示方式唯一
    * 要找相邻的边必须遍历对应行或列
    */
   ```

2. ```
   /*邻接表法
    * 空间复杂度（有向图） O(|V|+|E|) 无向图O(|v|+2|E|)
    * 表示方式不唯一
    * 存储稀疏图
    * 找有向图的入边很不方便要遍历整个表
    */
   ```

3. ```
   /*十字链表法
    * 只能用于存储有向图
    * 空间复杂度O(|V|+|E|)
    */
   ```

4. ```
   /*临界多重表
    *用于存储无向图
    *顶点结点：data + firstEdge（与该顶点相连的第一条边）
    *边结点： i + j + info + iLink（依附于顶点i的下一条边） + jLink(依附于顶点j的下一条边)
    *空间复杂度O（|V|+|E|）
    *删除边、删除节点等操作很方便
    */
   ```

5. Prim算法适于边稠密图 时间复杂度为O（|V|^2）从某一个顶点开始构建，每次将代价最小的新顶点纳入生成树

6. Kruskal算法 每次选择一条权值最小的边 使这条边的两头连通 时间复杂度O（|E|log2|E|）

7. 连通分量是指无向图中的极大连通子图（为本身图不是连通的设计的）

8. 生成树是包含所有顶点的极小连通子图（保证了连通，极小边数）

9. 无向图的度是依附于该顶点边的数目，有向图边的数目是入度+出度

10. 对于带权图的邻接矩阵，0和无穷都可以用于表达边不存在 无穷更多用于表达对角线上的值不存在

11. 子集不一定能构成子图，要保证子集本身先是个图

12. 强连通分量就是有向图的极大连通子图
